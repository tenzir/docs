name: Build OCSF Schemas
description: Build OCSF schemas locally using the official ocsf-server Elixir project

inputs:
  include-dev:
    description: Include -dev versions in the output
    required: false
    default: "true"

outputs:
  schemas-dir:
    description: Path to the directory containing exported schemas
    value: ${{ steps.schemas-dir.outputs.path }}
  versions:
    description: JSON array of exported version strings
    value: ${{ steps.export.outputs.versions || steps.read-versions.outputs.versions }}
  cache-hit:
    description: Whether schemas were restored from cache
    value: ${{ steps.schema-cache.outputs.cache-hit }}

runs:
  using: composite
  steps:
    - name: Setup Elixir
      uses: erlef/setup-beam@v1
      with:
        otp-version: "27"
        elixir-version: "1.17"

    - name: Clone OCSF repositories
      shell: bash
      run: |
        git clone --depth 1 https://github.com/ocsf/ocsf-server.git "$RUNNER_TEMP/ocsf-server"
        git clone https://github.com/ocsf/ocsf-schema.git "$RUNNER_TEMP/ocsf-schema"

    - name: Set schemas directory
      id: schemas-dir
      shell: bash
      run: |
        SCHEMAS_DIR="$RUNNER_TEMP/ocsf-schemas"
        mkdir -p "$SCHEMAS_DIR"
        echo "path=$SCHEMAS_DIR" >> "$GITHUB_OUTPUT"

    - name: Compute schema cache key
      id: cache-key
      shell: bash
      run: |
        cd "$RUNNER_TEMP/ocsf-schema"
        # Get all tag SHAs for version tags
        TAGS_HASH=$(git tag -l | grep -E '^v?[1-9][0-9]*\.[0-9]+\.[0-9]+(-dev)?$' | \
          xargs -I{} git rev-parse {} 2>/dev/null | sha256sum | cut -c1-16)
        SERVER_SHA=$(git -C "$RUNNER_TEMP/ocsf-server" rev-parse --short HEAD)
        SCRIPT_HASH=$(sha256sum "$GITHUB_ACTION_PATH/export_schema.exs" | cut -c1-8)
        echo "key=ocsf-schemas-${TAGS_HASH}-${SERVER_SHA}-${SCRIPT_HASH}" >> "$GITHUB_OUTPUT"

    - name: Restore schema cache
      id: schema-cache
      uses: actions/cache/restore@v4
      with:
        path: ${{ steps.schemas-dir.outputs.path }}
        key: ${{ steps.cache-key.outputs.key }}

    - name: Read versions from cache
      id: read-versions
      if: steps.schema-cache.outputs.cache-hit == 'true'
      shell: bash
      run: |
        VERSIONS=$(cat "${{ steps.schemas-dir.outputs.path }}/versions.json")
        echo "versions=$VERSIONS" >> "$GITHUB_OUTPUT"
        echo "Schema cache hit - versions: $VERSIONS"

    - name: Cache Elixir dependencies
      if: steps.schema-cache.outputs.cache-hit != 'true'
      uses: actions/cache@v4
      with:
        path: |
          ${{ runner.temp }}/ocsf-server/deps
          ${{ runner.temp }}/ocsf-server/_build
        key: ocsf-elixir-${{ runner.os }}-v1
        restore-keys: |
          ocsf-elixir-${{ runner.os }}-

    - name: Build OCSF server
      if: steps.schema-cache.outputs.cache-hit != 'true'
      shell: bash
      working-directory: ${{ runner.temp }}/ocsf-server
      run: |
        mix local.hex --force
        mix local.rebar --force
        mix deps.get
        mix compile

    - name: Export schemas for all versions
      if: steps.schema-cache.outputs.cache-hit != 'true'
      id: export
      shell: bash
      env:
        INCLUDE_DEV: ${{ inputs.include-dev }}
      run: |
        SCHEMAS_DIR="${{ steps.schemas-dir.outputs.path }}"

        cd "$RUNNER_TEMP/ocsf-schema"

        # Get all tags and filter to stable/dev versions
        # Formats: v1.0.0, v1.1.0, 1.3.0, 1.8.0-dev
        TAGS=$(git tag -l | grep -E '^v?[1-9][0-9]*\.[0-9]+\.[0-9]+(-dev)?$' || true)

        # Filter out -dev versions if not requested
        if [[ "$INCLUDE_DEV" != "true" ]]; then
          TAGS=$(echo "$TAGS" | grep -v '\-dev$' || true)
        fi

        # Sort versions semantically
        SORTED_TAGS=$(echo "$TAGS" | sed 's/^v//' | sort -t. -k1,1n -k2,2n -k3,3n | uniq)

        echo "Found versions: $SORTED_TAGS"

        VERSIONS_JSON="["
        FIRST=true

        for VERSION in $SORTED_TAGS; do
          echo "=== Processing version $VERSION ==="

          # Determine the git tag (could be v-prefixed or not)
          if git rev-parse "v$VERSION" >/dev/null 2>&1; then
            TAG="v$VERSION"
          else
            TAG="$VERSION"
          fi

          git checkout "$TAG" --quiet

          VERSION_DIR="$SCHEMAS_DIR/$VERSION"
          mkdir -p "$VERSION_DIR"

          # Run the export script with SCHEMA_DIR pointing to current schema checkout
          cd "$RUNNER_TEMP/ocsf-server"
          SCHEMA_DIR="$RUNNER_TEMP/ocsf-schema" \
          OUTPUT_DIR="$VERSION_DIR" \
          mix run "$GITHUB_ACTION_PATH/export_schema.exs" 2>&1 || {
            echo "Warning: Failed to export version $VERSION, skipping"
            rm -rf "$VERSION_DIR"
            cd "$RUNNER_TEMP/ocsf-schema"
            continue
          }

          cd "$RUNNER_TEMP/ocsf-schema"

          # Verify export succeeded
          if [[ -f "$VERSION_DIR/schema.json" ]]; then
            if [[ "$FIRST" == "true" ]]; then
              VERSIONS_JSON="$VERSIONS_JSON\"$VERSION\""
              FIRST=false
            else
              VERSIONS_JSON="$VERSIONS_JSON,\"$VERSION\""
            fi
            echo "Successfully exported version $VERSION"
          else
            echo "Warning: Export incomplete for version $VERSION"
            rm -rf "$VERSION_DIR"
          fi
        done

        VERSIONS_JSON="$VERSIONS_JSON]"

        # Write versions.json
        echo "$VERSIONS_JSON" > "$SCHEMAS_DIR/versions.json"

        echo "schemas-dir=$SCHEMAS_DIR" >> "$GITHUB_OUTPUT"
        echo "versions=$VERSIONS_JSON" >> "$GITHUB_OUTPUT"

        echo "=== Export complete ==="
        echo "Schemas directory: $SCHEMAS_DIR"
        echo "Versions: $VERSIONS_JSON"
        ls -la "$SCHEMAS_DIR"

    - name: Save schema cache
      if: steps.schema-cache.outputs.cache-hit != 'true'
      uses: actions/cache/save@v4
      with:
        path: ${{ steps.schemas-dir.outputs.path }}
        key: ${{ steps.cache-key.outputs.key }}
