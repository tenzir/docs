---
import { pathWithBase } from "@utils/base";
import { childTopics, rootTopics, topicParents } from "../topics.ts";

const { topics: sidebarTopics } = Astro.locals.starlightSidebarTopics;

// Find the current topic
const currentTopic = sidebarTopics.find((topic) => topic.isCurrent);

// Build navbar topics: always show the root topics
const navbarTopics = rootTopics();

// Get the current page path for fallback matching (e.g., "/changelog" or "/integrations/kafka")
const currentPath = Astro.url.pathname.replace(/\/$/, "");

// Determine if a given topic is "current" or an ancestor of the current one
function isTopicCurrentOrAncestor(label: string): boolean {
  // If we have a current topic from sidebar topics, use hierarchy matching
  if (currentTopic) {
    if (label === currentTopic.label) return true;
    let cursor = currentTopic.label;
    while (cursor) {
      const parent = topicParents[cursor];
      if (parent === label) return true;
      cursor = parent;
    }
    return false;
  }

  // Fallback: match by URL path prefix (for splash pages without sidebar topics)
  const topic = navbarTopics.find((t) => t.label === label);
  if (!topic) return false;

  // Handle root path
  if (topic.link === "/" || topic.link === "") {
    return currentPath === "" || currentPath === "/";
  }

  const topicPath = `/${topic.link}`;
  return currentPath === topicPath || currentPath.startsWith(`${topicPath}/`);
}
---

{navbarTopics.length > 0 && (
  <nav>
    <ul>
      {
      navbarTopics.map((topic) => (
      <li>
        <a
          href={pathWithBase(topic.link)}
          aria-current={isTopicCurrentOrAncestor(topic.label) ? 'page' : undefined}
          >
          {topic.label}
        </a>
      </li>
      ))
      }
    </ul>
  </nav>
)}

<style>
  nav {
    display: flex;
    align-items: center;
    height: 100%;
  }

  ul {
    display: flex;
    align-items: center;
    list-style: none;
    padding: 0;
    margin: 0;
    gap: var(--tnz-space-1);
    height: 100%;
  }

  li {
    display: flex;
    align-items: center;
    height: 100%;
  }

  a {
    display: flex;
    align-items: center;
    height: 100%;
    text-decoration: none;
    color: var(--tnz-nav-link);
    padding: 0 var(--tnz-space-2);
    font-size: var(--tnz-text-sm);
    font-weight: var(--tnz-font-medium);
    line-height: var(--tnz-leading-sm);
    transition: color var(--tnz-transition-base);
    position: relative;
    white-space: nowrap;
  }

  /* Bottom border indicator */
  a::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: var(--tnz-space-2);
    right: var(--tnz-space-2);
    height: 2px;
    background-color: transparent;
    transition: background-color var(--tnz-transition-base);
  }

  a:hover {
    color: var(--tnz-nav-link-hover);
  }

  a:focus-visible {
    color: var(--tnz-nav-link-hover);
    outline: none;
  }

  a:focus-visible::after {
    background-color: var(--tnz-neutral-400);
  }

  [aria-current="page"] {
    color: var(--tnz-nav-link-active);
  }

  [aria-current="page"]::after {
    background-color: var(--tnz-primary-500);
  }

  [aria-current="page"]:hover::after,
  [aria-current="page"]:focus-visible::after {
    background-color: var(--tnz-primary-500);
  }

</style>
