---
title: Configure reverse proxy
---

The platform uses 4 URLs that it exposes externally. You may
map these URLs to the same or different hostnames.

1. The URL that your browser connects to, e.g.,
   `app.platform.example`. This serves a web frontend where you can
   interact with the platform.
2. The URL that the nodes connect to, e.g., `nodes.platform.example`. Tenzir
   Nodes connect to this URL to establish long-running WebSocket connections.
3. The URL where the platform's S3-compatible blob storage is accessible,
   e.g., `downloads.platform.example`. When you use the _Download_ button,
   the platform generates download links under this URL. When you drag files
   into the explorer window, the platform stores them here so that Tenzir Nodes can
   access them.
4. The URL that the Tenzir Platform CLI connects to, e.g.,
   `api.platform.example`.

You must provide the following environment variables to the platform:

```sh
# The domain under which the platform frontend is reachable. Must include the
# `http://` or `https://` scheme.
TENZIR_PLATFORM_UI_ENDPOINT=https://app.platform.example

# The endpoint to which Tenzir nodes should connect. Must include the `ws://`
# or `wss://` scheme.
TENZIR_PLATFORM_NODES_ENDPOINT=wss://nodes.platform.example

# The URL at which the platform's S3-compatible blob storage is accessible at.
TENZIR_PLATFORM_DOWNLOADS_ENDPOINT=https://downloads.platform.example

# The URL at which the platform's S3-compatible blob storage is accessible at.
TENZIR_PLATFORM_API_ENDPOINT=https://api.platform.example
```

# Reverse Proxy

The recommended way to set up these URLs is to provision a HTTP reverse proxy
on the same host as the Tenzir Platform containers. This reverse proxy then
handles TLS termination for all of the above domains and forwards the traffic

# Native TLS

In some environments you cannot guarantee that the reverse proxy
runs on the same host machine as the other platform containers, or
the containers themselves are deployed to different machines.

In these scenarios, you need to enable native TLS support
for the individual platform containers.

## Obtaining Certificates

### From a Certificate Authority

The most straightforward and recommended way to obtain certificates is to
purchase the domain name you want for the platform and use one of the
globally trusted certificate authorities to obtain a valid certificate.

If you run the platform in a private or air-gapped network, you can use
methods like the DNS challenge offered by Let's Encrypt and other providers to
generate a certificate and transfer it to the target machine.

### Private Certificate Authority

When you cannot use a globally trusted certificate authority,
the alternative is to use a corporate root CA. Naturally, certificates from this
CA will only be trusted inside your organization or your Tenzir Platform setup.

If you do not possess a corporate root CA, it is also possible to create a
private certificate authority for yourself. Signing and provisioning root
certificates is a complex task, so for this purpose we recommend the use of
a tool like `trustme`.

We provide a [sample script](https://github.com/tenzir/platform/tree/main/examples/native-tls) that shows
how to create the necessary certificates for all components.

Note that some libraries ignore the system-wide CA certificate store and
alternative, more strictly curated bundles. For example, Mozilla's NSS root
store is a popular choice. Additionally, the OS default certificate bundles
shipped within our docker containers will not trust private CAs by default.
Therefore, when you use a private certificate authority, you will need to
perform the same configuration for corporate root CAs from a publicly trusted
certificate authority or your self-created private certificate authority.

### Self-signed certificates

Instead of creating a private certificate authority, you can also
create a self-signed certificate which combines certificate and CA in one
single file.

However, we do not recommend this approach since it nullifies several of the
security guarantees of TLS, only providing mere protection against passive
eavesdropping.

## Configuration

Below we assume that you store the valid TLS certificates in files named
`ssl/app-cert.pem`, `ssl/platform-cert.pem`, etc., where each file contains
both the TLS certificate and private key. If you store the certificate and private key
in separate files, you need to mount both into the containers and
adjust the environment variables to point towards the correct file.

When you use a private certificate authority, we assume that you store the public key
of that certificate authority in the file `ssl/ca.pem`.

### UI

To have the Tenzir UI serve its traffic using TLS, add the following environment
variables and volumes to your `docker-compose.yaml`:

```yaml
services:
  app:
    environment:
      - TLS_CERTFILE=/ssl/app-cert.pem
      - TLS_KEYFILE=/ssl/app-cert.pem

    volumes:
      - ./ssl/app-cert.pem:/ssl/app-cert.pem
```

When you use a private certificate authority, the following additional
configuration is necessary:

```yaml
services:
  app:
    environment:
      - NODE_EXTRA_CA_CERTS=/etc/ssl/certs/ca-certificates.crt

    volumes:
      - ./ssl/ca.pem:/etc/ssl/certs/ca-certificates.crt
```

### Gateway

To enable TLS serving for the Platform API, mount the certificate into the
container and set the `TLS_CERTFILE` and `TLS_KEYFILE` environment variables:

```yaml
services:
  websocket-gateway:
    environment:
      - TLS_CERTFILE=/ssl/gateway-cert.pem
      - TLS_KEYFILE=/ssl/gateway-cert.pem
    volumes:
      - ./ssl/gateway-cert.pem:/ssl/gateway-cert.pem
```

When you use a private certificate authority, the following additional
configuration is necessary:

```yaml
services:
  websocket-gateway:
    environment:
      - TLS_CAFILE=/ssl/ca.pem
    volumes:
      - ./ssl/ca.pem:/ssl/ca.pem
```

### Platform API

To enable TLS serving for the Platform API, mount the certificate into the
container and set the `TLS_CERTFILE` and `TLS_KEYFILE` environment variables.
This is the same process as for the `websocket-gateway` container:

```yaml
services:
  platform:
    environment:
      - TLS_CERTFILE=/ssl/platform-cert.pem
      - TLS_KEYFILE=/ssl/platform-cert.pem
    volumes:
      - ./ssl/platform-cert.pem:/ssl/platform-cert.pem
```

When you use a private certificate authority, the following additional
configuration is necessary:

```yaml
services:
  platform:
    environment:
      # 'requests' is using a baked-in CA bundle, so we need to point it to our CA explicitly.
      - REQUESTS_CA_BUNDLE=/etc/ssl/certs/ca-certificates.crt
      - SSL_CERT_FILE=/ssl/ca.pem
    volumes:
      volumes:
        - ./ssl/ca.pem:/etc/ssl/certs/ca-certificates.crt
```

### Example

Refer to our [native TLS example](https://github.com/tenzir/platform/tree/main/examples/native-tls) for a
complete configuration example, including the native TLS setup for the default
bundled database, S3 storage and IdP services.

# Node Settings

On the node, to trust a custom CA certificate, set the following option
to point to a CA certificate file in PEM format without password protection:

```sh
TENZIR_PLATFORM_CACERT=/path/to/ca-certificate.pem
```

If you want to use a self-signed TLS certificate, you need to disable
TLS certificate validation by setting:

```sh
TENZIR_PLATFORM_SKIP_PEER_VERIFICATION=true
```

Note that these settings only apply to the connection that the node establishes
with the platform, not to any TLS connections that pipelines may
create when running on the node.
