---
title: Configure reverse proxy
---

The platform uses 4 URLs that are exposed externally. These URLs may be
mapped to the same or different hostnames.

1. The URL that the user's browser connects to, e.g.,
   `app.platform.example`. This serves a web frontend where the user can
   interact with the platform.
2. The URL that the nodes connect to, e.g., `nodes.platform.example`. Tenzir
   Nodes connect to this URL to establish long-running WebSocket connections.
3. The URL that the platform's S3-compatible blob storage is accessible at,
   e.g., `downloads.platform.example`. When using the _Download_ button
   the platform generates download links under this URL. When dragging files
   into the explorer window, they are stored here so that Tenzir Nodes can
   access them.
4. The URL that the Tenzir Platform CLI connects to, e.g.,
   `api.platform.example`.

You must provide the following environment variables to the platform:

```sh
# The domain under which the platform frontend is reachable. Must include the
# `http://` or `https://` scheme.
TENZIR_PLATFORM_DOMAIN=https://app.platform.example

# The endpoint to which Tenzir nodes should connect. Must include the `ws://`
# or `wss://` scheme.
TENZIR_PLATFORM_CONTROL_ENDPOINT=wss://nodes.platform.example

# The URL at which the platform's S3-compatible blob storage is accessible at.
TENZIR_PLATFORM_BLOBS_ENDPOINT=https://downloads.platform.example

# The URL at which the platform's S3-compatible blob storage is accessible at.
TENZIR_PLATFORM_API_ENDPOINT=https://api.platform.example
```

# Reverse Proxy

The recommended way to set up these URLs is to provision a HTTP reverse proxy
on the same host as the Tenzir Platform containers. This reverse proxy then
handles TLS termination for all of the above domains and forwards the traffic

# Native TLS

In some environments the reverse proxy cannot be guaranteed
to run on the same host machine as the other platform containers, or
the containers themselves are deployed to different machines.

In these scenarios, it becomes necessary to enable native TLS support
for the individual platform containers.

## Obtaining Certificates

### From a Certificate Authority

The most straightforward and recommended way to obtain certificates is to
purchase the domain name you want to for the platform and use one of the
globally trusted certificate authorities to obtain a valid certificate.

If the platform is running in a private or air-gapped network, methods
like the DNS challenge offered by Let's Encrypt and other providers can be
used to generate a certificate that can be transferred to the target
machine.

### Private Certificate Authority

When the use of a globally trusted certificate authority is not possible,
the alternative is to create your own CA. Naturally, certificates from this
CA will only be trusted inside your organization or your platform setup.

Signing and provisioning root certificates is a complex task. If your
organization does not already have infrastructure to create and distribute
certificates from you internal certificate authority, we recommend the use of
a tool like `trustme`.

We prepared a [sample script](https://github.com/tenzir/platform/tree/main/examples/native-tls) that shows
how to create the necessary certificates for all components.

Note that some libraries ignore the system-wide CA certificate store and
alternative, more strictly curated bundles. For example, Mozilla's NSS root
store is a popular choice. Therefore, when using a private certificate authority
there will some configuration necessary even when the CA's root certificate
is already installed and trusted on all host systems.

### Self-signed certificates

Instead of creating a private certificate authority, it is also possible to
create a self-signed certificate which combines certificate and CA in one
single file.

However, we do not recommend this approach since it circumvents several of the
security guarantees of TLS, only providing a mere protection against passive
eavesdropping.

## Configuration

Below we assume that the valid TLS certificates are in files named
`ssl/app-cert.pem`, `ssl/platform-cert.pem`, etc., where each file contains
both the TLS certificate and private key. If the certificate and private key
are stored in separate files, both need to be mounted into the containers and
the environment variables and the environment variables need to be adjusted to
point towards the correct file.

When a private certificate authority is used, we assume that the public key
of that certificate authority is stored in the file `ssl/ca.pem`.

### UI

To have the Tenzir UI serve its traffic using TLS, add the following environment
variables and volumes to your `docker-compose.yaml`:

```yaml
services:
  app:
    environment:
      - TLS_CERTFILE=/ssl/app-cert.pem
      - TLS_KEYFILE=/ssl/app-cert.pem

    volumes:
      - ./ssl/app-cert.pem:/ssl/app-cert.pem
```

When using a private certificate authority, the following additional
configuration is necessary:

```yaml
services:
  app:
    environment:
      # In theory, this can point to an arbitrary file location. In practice,
      # some older node versions ignore the variable and only look
      # in the system default location.
      - NODE_EXTRA_CA_CERTS=/etc/ssl/certs/ca-certificates.crt

    volumes:
      - ./ssl/ca.pem:/etc/ssl/certs/ca-certificates.crt
```

### Gateway

To enable TLS serving for the Platform API, mount the certificate into the
container and set the `TLS_CERTFILE` and `TLS_KEYFILE` environment variables:

```yaml
services:
  websocket-gateway:
    environment:
      - TLS_CERTFILE=/ssl/gateway-cert.pem
      - TLS_KEYFILE=/ssl/gateway-cert.pem
    volumes:
      - ./ssl/gateway-cert.pem:/ssl/gateway-cert.pem
```

When using a private certificate authority, the following additional
configuration is necessary:

```yaml
services:
  websocket-gateway:
    environment:
      - TLS_CAFILE=/ssl/ca.pem
    volumes:
      - ./ssl/ca.pem:/ssl/ca.pem
```

### Platform API

To enable TLS serving for the Platform API, mount the certificate into the
container and set the `TLS_CERTFILE` and `TLS_KEYFILE` environment variables.
This is the same process as for the `websocket-gateway` container:

```yaml
services:
  platform:
    environment:
      - TLS_CERTFILE=/ssl/platform-cert.pem
      - TLS_KEYFILE=/ssl/platform-cert.pem
    volumes:
      - ./ssl/platform-cert.pem:/ssl/platform-cert.pem
```

When using a private certificate authority, the following additional
configuration is necessary:

```yaml
services:
  platform:
    environment:
      # 'requests' is using a baked-in CA bundle, so we need to point it to our CA explicitly.
      - REQUESTS_CA_BUNDLE=/etc/ssl/certs/ca-certificates.crt
      - SSL_CERT_FILE=/ssl/ca.pem
    volumes:
      volumes:
        - ./ssl/ca.pem:/etc/ssl/certs/ca-certificates.crt
```

### Example

Refer to our [native TLS example](https://github.com/tenzir/platform/tree/main/examples/native-tls) for a
complete configuration example, including the native TLS setup for the default
bundled database, S3 storage and IdP services.

# Node Settings

On the node, in order to trust a custom CA certificate, the following option
needs to point to a CA certificate file in PEM format without password protection:

```sh
TENZIR_PLATFORM_CACERT=/path/to/ca-certificate.pem
```

If you want to use a self-signed TLS certificate, you need to disable
TLS certificate validation by setting:

```sh
TENZIR_PLATFORM_SKIP_PEER_VERIFICATION=true
```

Note that these settings only apply to the connection that is established
between the node and the platform, not to any TLS connections that may
be created by running pipelines on the node.
