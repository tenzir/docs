import fs from "node:fs";
import path from "node:path";
import type { Html, Image, Root } from "mdast";
import type { Plugin } from "unified";
import { visit } from "unist-util-visit";
import type { VFile } from "vfile";
import { injectSvgAttrs } from "./html";

/**
 * Remark plugin that inlines SVG images directly into HTML.
 *
 * Transforms:
 * - ![alt](foo.excalidraw) -> <svg class="inline-svg excalidraw-diagram">...</svg>
 * - ![alt](foo.svg) -> <svg class="inline-svg">...</svg>
 *
 * Benefits:
 * - CSS dark mode works (SVG elements are in the DOM)
 * - Works in both dev and production builds
 * - No post-build HTML manipulation needed
 *
 * For .excalidraw references, reads the corresponding .svg file generated by
 * `bun run generate:excalidraw`.
 *
 * Only inlines local/relative SVGs. External URLs are left unchanged.
 */
export const remarkExcalidrawLinks: Plugin<[], Root> =
  () => (tree, file: VFile) => {
    visit(tree, "image", (node: Image, index, parent) => {
      if (!node.url) return;

      // Skip external URLs
      if (node.url.startsWith("http://") || node.url.startsWith("https://")) {
        return;
      }

      // Determine if this is an excalidraw or regular SVG
      const isExcalidraw = node.url.endsWith(".excalidraw");
      const isSvg = node.url.endsWith(".svg");

      if (!isExcalidraw && !isSvg) return;

      // Resolve the SVG path
      // For .excalidraw references, the generated SVG is foo.excalidraw.svg
      const svgUrl = isExcalidraw ? `${node.url}.svg` : node.url;

      // Get the directory of the current markdown file
      const fileDir = file.dirname || path.dirname(file.path || "");
      const svgPath = path.resolve(fileDir, svgUrl);

      // Try to read and inline the SVG
      let svgContent: string | null = null;
      try {
        if (fs.existsSync(svgPath)) {
          svgContent = fs.readFileSync(svgPath, "utf-8");
        } else if (process.env.NODE_ENV !== "production") {
        }
      } catch (_error) {
        if (process.env.NODE_ENV !== "production") {
        }
      }

      if (svgContent && parent && typeof index === "number") {
        // Build class list
        const classes = ["inline-svg"];
        if (isExcalidraw) classes.push("excalidraw-diagram");

        // Add class and accessibility attributes to the SVG element
        const alt = node.alt || "Diagram";
        svgContent = injectSvgAttrs(svgContent, classes.join(" "), alt);

        // Replace image node with inline HTML
        const htmlNode: Html = {
          type: "html",
          value: svgContent,
        };

        parent.children[index] = htmlNode;
      } else if (isExcalidraw) {
        // Fallback for excalidraw: rewrite URL to .excalidraw.svg (SVG not generated yet)
        node.url = svgUrl;
      }
      // For regular .svg that can't be inlined, leave as-is (img tag)
    });
  };

export default remarkExcalidrawLinks;
